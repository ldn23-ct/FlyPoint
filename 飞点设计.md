# 飞点设计

实际运动中的飞点束，射线源点位是固定的。因此每个体素接收到的角度有差异且数量固定。应当分别计算。

体素：m*m*d

像素：n*n

(1) 划分空间体素，就按当前模体来计算，空间是20cm*20cm*90mm。需要设计一个合理的尺寸。

(2) 源和探测器的相对位置固定，而模体移动。因此，理论上系统矩阵的计算不需要计算整个空间的点，而是扇束覆盖到的一个二维层或一个小三维体。我们需要做的是，在模体空间位置的变化过程中，提取出被射线覆盖到的部分来应用系统矩阵。

(3) 三维体素到二维体素的映射关系。
      输入：源相对模体的位置关系
      输出：参与计算的三维体素编号

(4) 二维体素系统矩阵的计算。需要分射线、分体素进行计算。同时还要从入射、出射两个角度进行计算。由于每个体素照射到的时间不均匀，因此从射线角度出发，按旋转角度进行等概率采样是符合物理模型的方式。

(5) 出射：计算每个体素对阵列中每个像素的透过率，形成一个mask。若被狭缝遮挡，直接赋0，否则计算出射方向的衰减程度（模长表示衰减程度）。mask shape: [k*d, n*n, 3]   angle shape: [k*d, n*n]

(6) 入射：要分角度。例如采样为 p 条射线，
      对于每条射线，首先计算初始入射强度；再找到该射线穿过的体素，要保存两个值，当前射线强度，入射向量（模长表示照射到当前体素的射线强度）。vector shape: [p, k*d, 3]

(7) 系统矩阵计算，在不考虑多重散射的前提下，需要计算入射衰减、出射衰减以及kn项。
      vector @ mask @ angle : 首先根据 vector mask 计算夹角导出kn项，
      kn matrix shape [p, k*d, n*n]；再进行矩阵乘法
      vector*kn*mask * angle = sys matrix
      sysmatrix shape: [p, k*d, n*n]     数量级大概在1e8
      考虑到飞点的特性，似乎可以通过调节速度的方式，对固定时间段内的响应进行合并，那么系统矩阵的可以压缩到 [k*d, n*n]   数量级降至1e6

(1) 稀疏性存储
    入射矩阵数据记录： data[k1, 3] pidx[k1, ] ptr[m+1, ]  体素光子通量
    出射矩阵数据记录： data[k2, 3] ptr[m+1, ] nidx[k2, ]  立体角、出射衰减
(2) 非0向量交集计算
    如果记录对应数据的midx，那么需要进行一个额外的交集判断，即入射和出射中均存在非0的m部分，但如果用ptr，即可以通过遍历每个m取出需要计算的值
    避免了对于m交集的判断
(3) 单次散射概率计算、系统矩阵计算
    需要有一个预先存储的体素电子密度矩阵 rho[]?
    最终的系统矩阵即 入射@出射*电子密度
    计算步骤：
    for i in range(ptr.shape[0]):
        A[a1:a2, ...]  pidx[a1:a2, ...]
        B[b1:b2, ...]  nidx[b1:b2, ...]
        kn ~ rho[mi, ] * costheta ~ A_uniform @ B_uniform.T
        sys = kn * A * B
        sum(sys, axis=p)
        return sys, pidx, nidx, mi
(4) 反投影计算
    接收数据为 x[t, ] y[t, ] and cnts
    需要根据时刻对计数信息进行划分，结合 x/y 判断当前扫描位置，再应用系统矩阵进行反投影

当前需要完成的
(1) 穿过狭缝修改，单条射线计算并反投影验证
(2) 在修改过后，每一个点的数据都要保留，目前相当于是一个超大矩阵，而非稀疏矩阵。仍然分为两部分，入射与出射。
    出射矩阵数据量：[m, n, 3], [m, n] 分别表示出射向量，以及出射后的各项衰减系数。其中 m = 700, n = 2.5e5
    因为太过于庞大，无法修改成所有射线统一运算，因此就改成单条射线，然后循环计算。
(3) 入射，这一项仍然是稀疏的。根据 p_i 取出对应的 [m_k], 对于 [m_k] 有对应的出射矩阵 [m_k, n]
    然后对入射和出射进行计算，分别是 kn项， 系数相乘，得到该条射线的系统矩阵
(4) 矩阵压缩，在计算时对探测器像素进行了进一步的划分，现在要重新合并回[50, 50], 即便最终由1e2数量的射线，最终矩阵的
    数量级为 1e2*700*2500 --> 1e8
    这是可以接受的

    申请的矩阵内存是 [p, m, 2.5e3] 即便如此，最终的数量级也到达了 1e9，对射线p不能合并，因此需要保留不同角度下的系统矩阵
    依旧对m进行遍历，每个m，出射矩阵 [2.5e5, 3] 参与计算，
    入射，根据 m_ptr，取出对应的 p_idx, vec, data，重新整合成一个 [k, 3] 的矩阵，其中 k 大概是个位数
    新的 vec[k, 3] 与 scatter[2.5e5, 3] 去进行计算
    会得到一个系数矩阵 sys [k, 2.5e5] 表示 第 k 条射线，经过第m个体素对探测器的响应
    然后对矩阵进行压缩，sys [k, 2.5e3]

两种计算方式：

1. 逐射线计算

1.1 入射计算，最终按稀疏格式进行输出，按射线进行遍历
    p_ptr  m_idx  vec  data
    记录了第p条射线穿过的体素索引m_idx，以及对应的入射方向向量vec1，入射强度data1

1.2 出射计算。第p条射线穿过的体素索引 m_idx(量级约为7e2)
    体素中心与探测器像素中心进行连线，表示为出射向量vec2[7e2, 2.5e5]
    对于每一条出射向量，都会进行出射计算(射线穿过挡板的距离，可以认为有5个不重叠的挡板)
    最终输出 vec2, data2 分别表示出射方向向量以及出射衰减

1.3 散射角计算。对于vec1以及vec2，需要计算二者的余弦值
    vec1[7e2, 3]  vec2[7e2, 2.5e5, 3]
    也就是说最终输出为 cos_theta [7e2, 2.5e5]
    然后根据康普顿散射微分截面计算公式，得到kn项系数，记作 kn [7e2, 2.5e5]

1.4 根据先前计算，有了入射衰减项 data1 [7e2, ]
    包含出射衰减以及到探测器像素立体角等影响因子，统称为出射衰减项 data2 [7e2, 2.5e5]
    以及因为康普顿散射引发的概率分布kn项 kn [7e2, 2.5e5]
    计算总的系统矩阵 data1[:, None] * data2 * kn --> sys [7e2, 2.5e5]

1.5 计算时探测器像素进行了细致划分[500, 500]，实际上探测器像素只有 [50, 50]，因此对系统矩阵进行合并计算 sys [7e2, 2.5e3]
    这样就对第p条射线的系统矩阵进行了计算。

1.6 重复上述计算过程，完成全部射线系统矩阵的计算 [1e2, 7e2, 2.5e3]

如果仍然想避免逐射线计算，需要验证一个问题，出射衰减计算后就合并，这影响的是kn项的角分辨率
那么要验证的第一个问题就是1mm与0.1mm划分，对于角分辨率的影响是否很大
