# 飞点设计

实际运动中的飞点束，射线源点位是固定的。因此每个体素接收到的角度有差异且数量固定。应当分别计算。

体素：m*m*d

像素：n*n

(1) 划分空间体素，就按当前模体来计算，空间是20cm*20cm*90mm。需要设计一个合理的尺寸。

(2) 源和探测器的相对位置固定，而模体移动。因此，理论上系统矩阵的计算不需要计算整个空间的点，而是扇束覆盖到的一个二维层或一个小三维体。我们需要做的是，在模体空间位置的变化过程中，提取出被射线覆盖到的部分来应用系统矩阵。

(3) 三维体素到二维体素的映射关系。
      输入：源相对模体的位置关系
      输出：参与计算的三维体素编号

(4) 二维体素系统矩阵的计算。需要分射线、分体素进行计算。同时还要从入射、出射两个角度进行计算。由于每个体素照射到的时间不均匀，因此从射线角度出发，按旋转角度进行等概率采样是符合物理模型的方式。

(5) 出射：计算每个体素对阵列中每个像素的透过率，形成一个mask。若被狭缝遮挡，直接赋0，否则计算出射方向的衰减程度（模长表示衰减程度）。mask shape: [k*d, n*n, 3]   angle shape: [k*d, n*n]

(6) 入射：要分角度。例如采样为 p 条射线，
      对于每条射线，首先计算初始入射强度；再找到该射线穿过的体素，要保存两个值，当前射线强度，入射向量（模长表示照射到当前体素的射线强度）。vector shape: [p, k*d, 3]

(7) 系统矩阵计算，在不考虑多重散射的前提下，需要计算入射衰减、出射衰减以及kn项。
      vector @ mask @ angle : 首先根据 vector mask 计算夹角导出kn项，
      kn matrix shape [p, k*d, n*n]；再进行矩阵乘法
      vector*kn*mask * angle = sys matrix
      sysmatrix shape: [p, k*d, n*n]     数量级大概在1e8
      考虑到飞点的特性，似乎可以通过调节速度的方式，对固定时间段内的响应进行合并，那么系统矩阵的可以压缩到 [k*d, n*n]   数量级降至1e6

(1) 稀疏性存储
    入射矩阵数据记录： data[k1, 3] pidx[k1, ] ptr[m+1, ]  体素光子通量
    出射矩阵数据记录： data[k2, 3] ptr[m+1, ] nidx[k2, ]  立体角、出射衰减
(2) 非0向量交集计算
    如果记录对应数据的midx，那么需要进行一个额外的交集判断，即入射和出射中均存在非0的m部分，但如果用ptr，即可以通过遍历每个m取出需要计算的值
    避免了对于m交集的判断
(3) 单次散射概率计算、系统矩阵计算
    需要有一个预先存储的体素电子密度矩阵 rho[]?
    最终的系统矩阵即 入射@出射*电子密度
    计算步骤：
    for i in range(ptr.shape[0]):
        A[a1:a2, ...]  pidx[a1:a2, ...]
        B[b1:b2, ...]  nidx[b1:b2, ...]
        kn ~ rho[mi, ] * costheta ~ A_uniform @ B_uniform.T
        sys = kn * A * B
        sum(sys, axis=p)
        return sys, pidx, nidx, mi
(4) 反投影计算
    接收数据为 x[t, ] y[t, ] and cnts
    需要根据时刻对计数信息进行划分，结合 x/y 判断当前扫描位置，再应用系统矩阵进行反投影

当前需要完成的
(1) 完成计算衰减的函数。输入为模体几何信息，射线向量，输出为每个体素接收到的光子通量。对于出射射线，只需要保留最后一层
(2) 根据指标要求效率、飞点转速以及平移速度，选择合适运动指标，进行体素划分
    ---- 按照计算，计数率一定要够大，12000/s合适，飞点转速 100r/min，重建体素大小5mm，
(3) 根据 x[t, ] 以及时间段长度，计算当前扫描体素序号
(4) 计数信息预处理。根据时刻以及位置信息，整合成为关于时间的探测器响应图 Re[n, t]
(5) 根据系统矩阵对响应进行反投影 sys[m, n] Re[n, ] sum(sys*Re[:, n], axis=1) ---> obj[m, ]
